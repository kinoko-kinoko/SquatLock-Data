name: Manus merge (all countries → root catalogs via PR)

on:
  push:
    paths:
      - 'data/manus/**/*.json'
      - 'data/manus/*.json'
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: List files to pass into Python
        id: list
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t FILES < <(find data/manus -type f -name '*.json' | sort || true)
          echo "Found ${#FILES[@]} manus drops."
          {
            echo "files<<EOF"
            for f in "${FILES[@]}"; do
              echo "$f"
            done
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Build merged catalogs (root/catalog_<cc>.json)
        id: build
        shell: bash
        env:
          MANUS_FILE_LIST: ${{ steps.list.outputs.files }}
        run: |
          set -euo pipefail
          python <<'PY'
          import json, os, re
          from collections import defaultdict
          from pathlib import Path

          flist = os.getenv('MANUS_FILE_LIST', '').splitlines()
          files = [Path(p) for p in flist if p.strip()]

          RE_CC = re.compile(r'(?:^|/)manus_([a-z]{2})_\d{8}\.json$', re.I)

          def as_list(v):
              if v is None: return []
              return v if isinstance(v, list) else [v]

          def dedup(seq):
              out, seen = [], set()
              for x in seq:
                  if x not in seen:
                      seen.add(x); out.append(x)
              return out

          def load_json(p: Path):
              with p.open('r', encoding='utf-8') as f:
                  return json.load(f)

          def dump_json(p: Path, data):
              tmp = p.with_suffix(p.suffix + '.tmp')
              with tmp.open('w', encoding='utf-8') as f:
                  json.dump(data, f, ensure_ascii=False, indent=2)
                  f.write('\n')
              tmp.replace(p)

          by_cc = defaultdict(list)

          for p in files:
              s = str(p).replace('\\','/')
              m = RE_CC.search(s)
              if m:
                  cc = m.group(1).lower()
              else:
                  parts = Path(s).parts
                  if 'manus' in parts:
                      i = parts.index('manus')
                      cc = parts[i+1].lower() if i+1<len(parts) and len(parts[i+1])==2 else None
                  else:
                      cc = None
              if not cc:
                  continue

              try:
                  data = load_json(p)
                  items = (data.get('apps') or data.get('items') or
                           data.get('data') or data.get('list') or
                           data.get('entries') or data)
                  if not isinstance(items, list):
                      items = [items]

                  normed = []
                  for it in items:
                      if not isinstance(it, dict): continue
                      it = it.copy()
                      it['id'] = (str(it.get('id') or it.get('name') or '').strip() or None)
                      if not it['id']: continue
                      it['name'] = str(it.get('name') or it['id']).strip()
                      it['symbol'] = it.get('symbol') or 'app.fill'
                      it['schemes'] = [s.strip() for s in as_list(it.get('schemes')) if isinstance(s,str) and s.strip()]
                      it['universalLinks'] = [u.strip() for u in as_list(it.get('universalLinks')) if isinstance(u,str) and u.strip()]
                      it['webHosts'] = [h.strip() for h in as_list(it.get('webHosts')) if isinstance(h,str) and h.strip()]
                      it['aliases'] = [a.strip() for a in as_list(it.get('aliases')) if isinstance(a,str) and a.strip()]
                      it['categories'] = [c.strip() for c in as_list(it.get('categories')) if isinstance(c,str) and c.strip()]
                      src = it.get('source') or {}
                      if not isinstance(src, dict): src = {}
                      src['country'] = src.get('country') or cc.upper()
                      via = as_list(src.get('via')); via.append('manus')
                      src['via'] = dedup([v for v in via if v])
                      it['source'] = src
                      it['schemes'] = dedup(it['schemes'])
                      it['universalLinks'] = dedup(it['universalLinks'])
                      it['webHosts'] = dedup(it['webHosts'])
                      it['aliases'] = dedup(it['aliases'])
                      it['categories'] = dedup(it['categories'])
                      normed.append(it)

                  if normed:
                      by_cc[cc].extend(normed)
              except Exception as e:
                  print(f"[warn] skip {p}: {e}")

          changed = []

          for cc, items in by_cc.items():
              out = Path(f"catalog_{cc}.json")
              existing = []
              if out.exists():
                  try:
                      existing = load_json(out)
                      if not isinstance(existing, list):
                          existing = []
                  except Exception:
                      existing = []

              by_id = {it.get('id'): it for it in existing if isinstance(it, dict) and it.get('id')}

              for it in items:
                  _id = it['id']
                  if _id in by_id:
                      cur = by_id[_id].copy()
                      for k in ('name','symbol'):
                          if it.get(k): cur[k] = it[k]
                      def uni(k):
                          cur[k] = sorted(set(as_list(cur.get(k)) + as_list(it.get(k))))
                      for k in ('schemes','universalLinks','webHosts','aliases','categories'):
                          uni(k)
                      cur_src = cur.get('source') or {}
                      it_src = it.get('source') or {}
                      new_src = {
                          'country': (it_src.get('country') or cur_src.get('country')),
                          'via': sorted(set(as_list(cur_src.get('via')) + as_list(it_src.get('via'))))
                      }
                      cur['source'] = new_src
                      by_id[_id] = cur
                  else:
                      by_id[_id] = it

              merged = sorted(by_id.values(), key=lambda x: x.get('id',''))

              # 既存と同じなら書き換えない → changed にも入れない
              if existing == merged:
                  continue

              dump_json(out, merged)
              changed.append(cc)

          with open(os.environ['GITHUB_OUTPUT'],'a',encoding='utf-8') as g:
              g.write('changed=' + '\\n'.join(changed) + '\\n')
          PY

      - name: Commit changes on branch
        id: commit
        if: steps.build.outputs.changed != ''
        shell: bash
        run: |
          set -euo pipefail
          TS="$(date +'%Y%m%d-%H%M%S')"
          BR="chore/manus/${TS}"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BR"

          shopt -s nullglob
          FILES=(catalog_*.json)
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "No catalog files present."
            echo "branch=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 差分がなければスキップ（成功終了）
          if git diff --quiet -- "${FILES[@]}"; then
            echo "No diff in catalog_*.json; skip commit/PR."
            echo "branch=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git add "${FILES[@]}"
          git commit -m "chore(manus): merge drops into catalogs (${TS})"
          git push -u origin "$BR"
          echo "branch=$BR" >> "$GITHUB_OUTPUT"

      - name: Open PR (label:manus,catalog; comment:squash)
        if: steps.commit.outputs.branch != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const branch = '${{ steps.commit.outputs.branch }}';
            const {owner, repo} = context.repo;
            const title = `chore(manus): merge drops into catalogs (${new Date().toISOString().slice(0,10)})`;
            const body = [
              'Manus の出力を各国カタログへ自動マージしました。',
              '',
              '— 置き場: `data/manus/**/manus_<cc>_YYYYMMDD.json`（フラットでもOK）',
              '— 既存項目にも安全に統合（配列はユニオン、source.via に `manus` 付与）',
              '',
              '🟢 マージ方法: **Squash and merge** を選択してください（コミットに日付が残ります）'
            ].join('\n');
            const pr = await github.rest.pulls.create({ owner, repo, title, body, head: branch, base: 'main' });
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.data.number, labels: ['catalog','manus'] });
            } catch {}
