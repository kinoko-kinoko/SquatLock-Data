name: Manus merge (all countries → root catalogs via PR)

on:
  push:
    paths:
      - 'data/manus/**/*.json'
      - 'data/manus/*.json'
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: List files to pass into Python
        id: list_files
        shell: bash
        run: |
          set -e
          mapfile -t FILES < <(find data/manus -type f -name '*.json' | sort)
          printf '%s\n' "${FILES[@]}" | tee files.txt
          # 改行を \n にエスケープして outputs へ
          {
            printf 'files<<EOF\n'
            printf '%s\n' "${FILES[@]}"
            printf 'EOF\n'
          } >> "$GITHUB_OUTPUT"

      - name: Build merged catalogs (root/catalog_<cc>.json)
        id: build
        env:
          MANUS_FILE_LIST: ${{ steps.list_files.outputs.files }}
        shell: bash
        run: |
          set -euo pipefail

          python <<'PY'
          import json, os, re, sys
          from pathlib import Path
          from collections import defaultdict

          # 受け渡し（複数行）
          flist = os.getenv('MANUS_FILE_LIST', '').splitlines()
          files = [Path(p.strip()) for p in flist if p.strip()]

          if not files:
            # 変更なし
            with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as g:
              g.write('changed=\n')
            sys.exit(0)

          RE_MANUS = re.compile(r'(?:^|/)manus_([a-z]{2})_\d{8}\.json$', re.I)

          def key_cc_for(path: Path):
            s = str(path).replace('\\','/')
            m = RE_MANUS.search(s)
            if m:
              return m.group(1).lower()
            # data/manus/<cc>/xxx.json パターン対応
            parts = Path(s).parts
            if 'manus' in parts:
              i = parts.index('manus')
              if i+1 < len(parts) and len(parts[i+1]) == 2:
                return parts[i+1].lower()
            return None

          def as_list(v):
            if v is None: return []
            if isinstance(v, list): return v
            return [v]

          def dedup_keep_order(seq):
            seen = set()
            out = []
            for x in seq:
              if x not in seen:
                seen.add(x); out.append(x)
            return out

          def load_any(path: Path):
            with open(path, 'r', encoding='utf-8') as f:
              return json.load(f)

          def normalize_items(data, cc):
            """
            data が:
              - [ {...}, {...} ]（配列）
              - { "apps": [ ... ] } または { "items": [ ... ] } など
              - { 単一オブジェクト }
            の全てを apps 配列に正規化
            """
            # 配列
            if isinstance(data, list):
              items = data
            # オブジェクト
            elif isinstance(data, dict):
              for k in ('apps','items','data','list','entries'):
                if isinstance(data.get(k), list):
                  items = data[k]
                  break
              else:
                # 単一
                items = [data]
            else:
              return []

            out = []
            for it in items:
              if not isinstance(it, dict): 
                continue
              it = dict(it)  # copy
              _id = (str(it.get('id') or it.get('name') or '').strip() or None)
              if not _id:
                continue
              it['id'] = _id
              it['name'] = str(it.get('name') or _id)
              it['symbol'] = it.get('symbol') or 'app.fill'
              it['schemes'] = [s.strip() for s in as_list(it.get('schemes')) if isinstance(s, str) and s.strip()]
              it['universalLinks'] = [u.strip() for u in as_list(it.get('universalLinks')) if isinstance(u, str) and u.strip()]
              it['webHosts'] = [h.strip() for h in as_list(it.get('webHosts')) if isinstance(h, str) and h.strip()]
              it['aliases'] = [a.strip() for a in as_list(it.get('aliases')) if isinstance(a, str) and a.strip()]
              it['categories'] = [c.strip() for c in as_list(it.get('categories')) if isinstance(c, str) and c.strip()]

              # source 補完
              src = it.get('source') if isinstance(it.get('source'), dict) else {}
              src = dict(src)
              src['country'] = (src.get('country') or cc.upper())
              via = as_list(src.get('via'))
              via.append('manus')
              src['via'] = dedup_keep_order([v for v in via if v])
              it['source'] = src

              # 配列の重複除去
              for k in ('schemes','universalLinks','webHosts','aliases','categories'):
                it[k] = dedup_keep_order(it[k])

              out.append(it)
            return out

          root = Path('.')
          by_cc = defaultdict(list)

          for p in files:
            cc = key_cc_for(p)
            if not cc:
              continue
            try:
              data = load_any(p)
              by_cc[cc].extend(normalize_items(data, cc))
            except Exception as e:
              print(f"[warn] skip {p}: {e}")

          changed = []

          for cc, new_items in by_cc.items():
            out_path = root / f"catalog_{cc}.json"

            # 既存の形は { "version": 1, "apps": [ ... ] }
            existing = {"version": 1, "apps": []}
            if out_path.exists():
              try:
                ex = load_any(out_path)
                if isinstance(ex, dict) and isinstance(ex.get('apps'), list):
                  existing = ex
              except Exception:
                pass

            # id マージ
            idx = {it.get('id'): it for it in existing.get('apps', []) if isinstance(it, dict) and it.get('id')}
            for it in new_items:
              _id = it['id']
              if _id in idx:
                cur = dict(idx[_id])
                # 単純プロパティは新規優先
                for k in ('name','symbol'):
                  if it.get(k): cur[k] = it[k]
                # 配列はユニオン
                def uni(k):
                  cur[k] = dedup_keep_order(as_list(cur.get(k)) + as_list(it.get(k)))
                for k in ('schemes','universalLinks','webHosts','aliases','categories'):
                  uni(k)
                # source.via ユニオン / country は何れか
                cur_src = cur.get('source') if isinstance(cur.get('source'), dict) else {}
                it_src  = it.get('source')  if isinstance(it.get('source'), dict)  else {}
                via = dedup_keep_order(as_list(cur_src.get('via')) + as_list(it_src.get('via')))
                country = it_src.get('country') or cur_src.get('country')
                cur['source'] = {'country': country, 'via': via}
                idx[_id] = cur
              else:
                idx[_id] = it

            merged = {"version": 1, "apps": sorted(idx.values(), key=lambda x: x.get('id',''))}

            # 変化があるときのみ書き込み
            new_text = json.dumps(merged, ensure_ascii=False, indent=2) + "\n"
            old_text = ""
            if out_path.exists():
              try:
                old_text = out_path.read_text(encoding='utf-8')
              except Exception:
                pass
            if new_text != old_text:
              out_path.write_text(new_text, encoding='utf-8')
              changed.append(cc)

          with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as g:
            g.write('changed=' + ('\n'.join(changed) if changed else '') + '\n')
          PY

      - name: Commit changes on branch
        id: commit
        if: steps.build.outputs.changed != ''
        shell: bash
        run: |
          set -euo pipefail
          TS="$(date +'%Y%m%d-%H%M%S')"
          BR="chore/manus/${TS}"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BR"
          git add catalog_*.json
          git commit -m "chore(manus): merge drops into catalogs (${TS})"
          git push -u origin "$BR"
          echo "branch=${BR}" >> "$GITHUB_OUTPUT"

      - name: Open PR (label:manus,catalog;comment:squash)
        if: steps.commit.outputs.branch != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const branch = '${{ steps.commit.outputs.branch }}';
            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const title  = `chore(manus): merge drops into catalogs (${new Date().toISOString().slice(0,10)})`;
            const body   = [
              'Manus の出力を各国カタログへ自動マージしました。',
              '',
              '— 置き場: `data/manus/**/manus_<cc>_YYYYMMDD.json` または `data/manus/<cc>/*.json`',
              '— 既存項目にも安全に統合（配列はユニオン、source.via に `manus` 付与）',
              '',
              '🟢 マージ方法: **Squash and merge** を選択してください（コミットは1つに集約）'
            ].join('\n');
            const pr = await github.rest.pulls.create({ owner, repo, head: branch, base: 'main', title, body });
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.data.number, labels: ['catalog','manus'] });
            } catch (_) {}
