name: Manus merge (all countries, nested folders OK)

on:
  push:
    paths:
      - 'data/manus/**/*.json'
      - 'data/manus/*.json'
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Merge Manus drops into per-country catalogs
        id: merge
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, re, glob, os, sys
          from pathlib import Path
          
          root = Path('.')
          # 再帰・フラット両対応
          drop_files = []
          drop_files += glob.glob('data/manus/**/*.json', recursive=True)
          drop_files += glob.glob('data/manus/*.json')

          # 重複除去
          drop_files = sorted(set(drop_files))

          if not drop_files:
            print("no manuscript files")
            sys.exit(0)

          def load_json(p):
            with open(p, 'r', encoding='utf-8') as f:
              return json.load(f)

          def save_json(p, obj):
            p.parent.mkdir(parents=True, exist_ok=True)
            with open(p, 'w', encoding='utf-8') as f:
              json.dump(obj, f, ensure_ascii=False, indent=2)
              f.write('\n')

          # country code の推定：ファイル名優先 -> 親フォルダ
          fn_cc = re.compile(r'manus_([a-z]{2})_\d{8}\.json$', re.I)

          def infer_cc(path: Path):
            m = fn_cc.search(path.name)
            if m:
              return m.group(1).lower()
            parent = path.parent.name.lower()
            if re.fullmatch(r'[a-z]{2}', parent):
              return parent
            # フォールバック：global を使うならここで返す
            return None

          def normalize_entry(e: dict, cc: str|None):
            # source.via に manus を付ける（重複回避）
            src = e.get('source', {})
            via = src.get('via')
            if isinstance(via, list):
              if 'manus' not in via:
                via.append('manus')
            elif isinstance(via, str):
              if via != 'manus':
                src['via'] = [via, 'manus']
            else:
              src['via'] = 'manus'
            if cc and 'country' not in src:
              # 既に country が明示的なら尊重。無ければ cc 推定を入れておく（任意）
              src['country'] = cc.upper()
            e['source'] = src
            # 空 collection の正規化
            for k in ('schemes','universalLinks','webHosts','aliases','categories'):
              if k in e and e[k] is None:
                e[k] = []
            return e

          def merge_catalog(old: list[dict], new: list[dict]):
            # id 基準で上書きマージ、配列はユニオン寄りに
            by_id = { (x.get('id') or x.get('name')): x for x in old if (x.get('id') or x.get('name')) }
            for e in new:
              key = e.get('id') or e.get('name')
              if not key:
                continue
              if key not in by_id:
                by_id[key] = e
                continue
              dest = by_id[key]
              # 単純フィールドは new 優先で上書き
              for k in ('id','name','symbol'):
                if k in e: dest[k] = e[k]
              # 配列はユニオン（順不同）
              def ucat(k):
                a = dest.get(k, []) or []
                b = e.get(k, []) or []
                dest[k] = sorted(set(a) | set(b))
              for k in ('schemes','universalLinks','webHosts','aliases','categories'):
                ucat(k)
              # source は浅いマージ（via はユニオン）
              s0 = dest.get('source', {}) or {}
              s1 = e.get('source', {}) or {}
              via0 = s0.get('via')
              via1 = s1.get('via')
              def via_list(v):
                if v is None: return []
                if isinstance(v, list): return v
                return [v]
              merged_via = sorted(set(via_list(via0) + via_list(via1)))
              s0.update(s1)
              if merged_via:
                s0['via'] = merged_via if len(merged_via)>1 else merged_via[0]
              dest['source'] = s0

            # 配列に戻す
            return sorted(by_id.values(), key=lambda x: (x.get('name') or '', x.get('id') or ''))

          changed = False
          touched = set()

          for f in drop_files:
            p = Path(f)
            cc = infer_cc(p)
            data = load_json(p)
            if not isinstance(data, list):
              # もし {apps:[...]} 形式なら吸い上げ
              if isinstance(data, dict) and 'apps' in data and isinstance(data['apps'], list):
                data = data['apps']
              else:
                print(f"skip {p} (not a list json)")
                continue
            data = [normalize_entry(e, cc) for e in data if isinstance(e, dict)]

            # ccごとのカタログ先を決定（cc無ければ global に入れる運用も可）
            if cc is None:
              catalog_path = Path('scripts/catalog_global.json')
            else:
              catalog_path = Path(f'scripts/catalog_{cc}.json')

            # 既存読み込み
            if catalog_path.exists():
              old = load_json(catalog_path)
              if not isinstance(old, list): old = []
            else:
              old = []

            merged = merge_catalog(old, data)

            if json.dumps(old, sort_keys=True) != json.dumps(merged, sort_keys=True):
              save_json(catalog_path, merged)
              changed = True
              touched.add(str(catalog_path))

          if changed:
            print("::set-output name=changed::true")
            print("Touched:", ','.join(sorted(touched)))
          else:
            print("::set-output name=changed::false")
          PY

      - name: Create PR
        if: steps.merge.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore(manus): merge drops into catalogs"
          title: "chore(manus): merge drops into catalogs"
          body: |
            Manus の出力を各国カタログへ自動マージしました。
            - 置き場: `data/manus/**/manus_<cc>_<YYYYMMDD>.json`（フラット置きもOK）
            - `source.via` に `manus` を自動付与
            - 既存項目はユニオン/上書きで安全に統合
          branch: chore/manus-merge
          labels: manus, catalog
          add-paths: |
            scripts/catalog_*.json
          delete-branch: true
