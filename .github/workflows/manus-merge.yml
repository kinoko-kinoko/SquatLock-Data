name: Manus merge (all countries â†’ root catalogs via PR)

on:
  push:
    paths:
      - 'data/manus/**/*.json'
      - 'data/manus/*.json'

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Build merged catalogs (root/catalog_<cc>.json)
        id: build
        shell: bash
        run: |
          set -euo pipefail

          echo "Scanning manus drops..."
          # ã™ã¹ã¦ã® manus JSON ã‚’æ‹¾ã†ï¼ˆãƒã‚¹ãƒˆ/ãƒ•ãƒ©ãƒƒãƒˆã©ã¡ã‚‰ã‚‚OKï¼‰
          mapfile -t FILES < <(find data/manus -type f -name '*.json' | sort)

          if [ ${#FILES[@]} -eq 0 ]; then
            echo "No manus files found. Skip."
            echo "changed=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found files:"
          printf ' - %s\n' "${FILES[@]}"

          # Python ã§ãƒãƒ¼ã‚¸ï¼ˆå›½åˆ¥ã« catalog_<cc>.json ã‚’å†ç”Ÿæˆï¼‰
          python <<'PY'
          import json, os, re, sys
          from collections import defaultdict
          from pathlib import Path
          RE_CC = re.compile(r'(?:^|/)manus_([a-z]{2})_\d{8}\.json$', re.I)

          root = Path('.')
          files = [Path(p.strip()) for p in sys.stdin if p.strip()] if False else []
          # ä¸Šã®ãƒ‘ã‚¹å—ã‘æ¸¡ã—ã‚’ç°¡å˜ã«ã™ã‚‹ãŸã‚ã€ç’°å¢ƒå¤‰æ•° MANUS_FILE_LIST ã‚’ä½¿ã†
          flist = os.getenv('MANUS_FILE_LIST', '')
          files = [Path(p) for p in flist.split('\n') if p]

          def load_json(path):
            with open(path, 'r', encoding='utf-8') as f:
              return json.load(f)

          def dump_json(path, data):
            tmp = path.with_suffix(path.suffix + '.tmp')
            with open(tmp, 'w', encoding='utf-8') as f:
              json.dump(data, f, ensure_ascii=False, indent=2)
              f.write('\n')
            tmp.replace(path)

          def as_list(v):
            if v is None: return []
            if isinstance(v, list): return v
            return [v]

          def dedup(seq):
            seen = set()
            out = []
            for x in seq:
              if x not in seen:
                seen.add(x)
                out.append(x)
            return out

          # files ã¯ bash å´ã‹ã‚‰ç’°å¢ƒå¤‰æ•°ã§æ¸¡ã™
          by_cc = defaultdict(list)
          for p in files:
            s = str(p).replace('\\','/')
            m = RE_CC.search(s)
            if not m:
              # data/manus/<cc>/xxx.json ã®ã‚ˆã†ãªè‡ªå‰é‹ç”¨ã®å¯èƒ½æ€§ã‚‚è€ƒæ…®
              # ãã®å ´åˆã¯è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã‹ã‚‰æ¨æ¸¬ï¼ˆ2æ–‡å­—ãªã‚‰å›½ã‚³ãƒ¼ãƒ‰æ‰±ã„ï¼‰
              parts = Path(s).parts
              if 'manus' in parts:
                i = parts.index('manus')
                if i+1 < len(parts) and len(parts[i+1]) == 2:
                  cc = parts[i+1].lower()
                  pass_cc = True
                else:
                  pass_cc = False
              else:
                pass_cc = False
              if not pass_cc:
                # èªè­˜ã§ããªã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
                continue
              cc = parts[i+1].lower()
            else:
              cc = m.group(1).lower()

            try:
              data = load_json(p)
              if isinstance(data, dict):
                # å˜ä¸€ or é…åˆ—ã‚’å†…åŒ…ã®å¯èƒ½æ€§
                candidates = data.get('apps') or data.get('items') or data.get('data') or data.get('list') or data.get('entries')
                if candidates is None:
                  # ãã®ã¾ã¾ dictâ†’é…åˆ—æ‰±ã„
                  items = [data]
                else:
                  items = candidates
              else:
                items = data

              if not isinstance(items, list):
                items = [items]

              # æ­£è¦åŒ–
              normed = []
              for it in items:
                if not isinstance(it, dict):
                  continue
                it = it.copy()
                it['id'] = str(it.get('id') or it.get('name') or '').strip() or None
                it['name'] = str(it.get('name') or it.get('id') or '').strip()
                it['symbol'] = it.get('symbol') or 'app.fill'
                it['schemes'] = [s.strip() for s in as_list(it.get('schemes')) if s and isinstance(s, str)]
                it['universalLinks'] = [u.strip() for u in as_list(it.get('universalLinks')) if u and isinstance(u, str)]
                it['webHosts'] = [h.strip() for h in as_list(it.get('webHosts')) if h and isinstance(h, str)]
                it['aliases'] = [a.strip() for a in as_list(it.get('aliases')) if a and isinstance(a, str)]
                it['categories'] = [c.strip() for c in as_list(it.get('categories')) if c and isinstance(c, str)]

                # source ã‚’å¢—è£œ
                src = (it.get('source') or {})
                if not isinstance(src, dict): src = {}
                src['country'] = (src.get('country') or cc.upper())
                via = src.get('via')
                via_list = [via] if isinstance(via, str) and via else as_list(via)
                via_list.append('manus')
                src['via'] = dedup([v for v in via_list if v])
                it['source'] = src

                # id ç„¡ã—ã¯é™¤å¤–
                if not it['id']:
                  continue
                # é…åˆ—ã®é‡è¤‡æ•´å½¢
                it['schemes'] = dedup(it['schemes'])
                it['universalLinks'] = dedup(it['universalLinks'])
                it['webHosts'] = dedup(it['webHosts'])
                it['aliases'] = dedup(it['aliases'])
                it['categories'] = dedup(it['categories'])

                normed.append(it)

              if normed:
                by_cc[cc].extend(normed)
            except Exception as e:
              print(f"[warn] skip {p}: {e}")

          changed_cc = []

          for cc, items in by_cc.items():
            out_path = root / f"catalog_{cc}.json"
            existing = []
            if out_path.exists():
              try:
                existing = load_json(out_path)
                if not isinstance(existing, list):
                  existing = []
              except Exception:
                existing = []

            # æ—¢å­˜ã¨çµ±åˆï¼ˆid ã‚­ãƒ¼ã§ãƒãƒ¼ã‚¸ï¼‰
            by_id = {it.get('id'): it for it in existing if isinstance(it, dict) and it.get('id')}
            for it in items:
              _id = it['id']
              if _id in by_id:
                cur = by_id[_id].copy()
                # åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯æ–°è¦ãŒå„ªå…ˆï¼ˆname/symbolãªã©ï¼‰
                for k in ('name','symbol'):
                  if it.get(k): cur[k] = it[k]
                # é…åˆ—ç³»ã¯ãƒ¦ãƒ‹ã‚ªãƒ³
                def uni(k):
                  cur[k] = sorted(set(as_list(cur.get(k)) + as_list(it.get(k))))
                for k in ('schemes','universalLinks','webHosts','aliases','categories'):
                  uni(k)
                # source ã¯ country ã‚’å°Šé‡ã—ã¤ã¤ via ã‚’ãƒ¦ãƒ‹ã‚ªãƒ³
                cur_src = cur.get('source') or {}
                it_src = it.get('source') or {}
                new_src = {
                  'country': (it_src.get('country') or cur_src.get('country')),
                  'via': sorted(set(as_list(cur_src.get('via')) + as_list(it_src.get('via'))))
                }
                cur['source'] = new_src
                by_id[_id] = cur
              else:
                by_id[_id] = it

            # å‡ºåŠ›ï¼ˆid ã‚½ãƒ¼ãƒˆï¼‰
            merged = sorted(by_id.values(), key=lambda x: x.get('id',''))
            dump_json(out_path, merged)
            changed_cc.append(cc)

          # å¤‰æ›´ã—ãŸå›½ã‚³ãƒ¼ãƒ‰ï¼ˆæ”¹è¡ŒåŒºåˆ‡ã‚Šï¼‰ã‚’ GITHUB_OUTPUT ã¸
          with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as g:
            g.write('changed=' + '\\n'.join(changed_cc) + '\\n')
          PY
        env:
          # bash ã‹ã‚‰ Python ã¸ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’æ–‡å­—åˆ—ã§æ¸¡ã™
          MANUS_FILE_LIST: ${{ steps.list_files.outputs.files || '' }}
        # â†‘ Python ã«æ¸¡ã™ãƒªã‚¹ãƒˆã®ãŸã‚ã€ç›´å‰ã« list_files ã‚’å‹•ã‹ã™
        #   â†’ ä¸‹ã§åˆ¥ step ã§æ‹¾ã†ã®ã§ã€ã“ã® step ã® env ã¯å·®ã—æ›¿ãˆã‚‹
      - name: List files to pass into Python
        id: list_files
        shell: bash
        run: |
          set -e
          mapfile -t FILES < <(find data/manus -type f -name '*.json' | sort)
          printf '%s\n' "${FILES[@]}" | tee files.txt
          echo "files=$(printf '%s\n' "${FILES[@]}")" >> "$GITHUB_OUTPUT"

      - name: Commit changes on branch
        id: commit
        if: steps.build.outputs.changed != ''
        shell: bash
        run: |
          set -euo pipefail
          TS="$(date +'%Y%m%d-%H%M%S')"
          BR="chore/manus/${TS}"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BR"
          git add catalog_*.json
          git commit -m "chore(manus): merge drops into catalogs (${TS})"
          git push -u origin "$BR"
          echo "branch=$BR" >> "$GITHUB_OUTPUT"

      - name: Open PR (label: manus, catalog; comment squash)
        if: steps.commit.outputs.branch != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const branch = '${{ steps.commit.outputs.branch }}';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const title = `chore(manus): merge drops into catalogs (${new Date().toISOString().slice(0,10)})`;
            const body = [
              'Manus ã®å‡ºåŠ›ã‚’å„å›½ã‚«ã‚¿ãƒ­ã‚°ã¸è‡ªå‹•ãƒãƒ¼ã‚¸ã—ã¾ã—ãŸã€‚',
              '',
              'â€” ç½®ãå ´: `data/manus/**/manus_<cc>_YYYYMMDD.json`ï¼ˆãƒ•ãƒ©ãƒƒãƒˆã§ã‚‚OKï¼‰',
              'â€” æ—¢å­˜é …ç›®ã«ã‚‚å®‰å…¨ã«çµ±åˆï¼ˆé…åˆ—ã¯ãƒ¦ãƒ‹ã‚ªãƒ³ã€source.via ã« `manus` ä»˜ä¸ï¼‰',
              '',
              'ğŸŸ¢ ãƒãƒ¼ã‚¸æ–¹æ³•: **Squash and merge** ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆã‚³ãƒŸãƒƒãƒˆã«æ—¥ä»˜ãŒæ®‹ã‚Šã¾ã™ï¼‰'
            ].join('\n');

            const pr = await github.rest.pulls.create({
              owner,
              repo,
              title,
              body,
              head: branch,
              base: 'main'
            });

            // ãƒ©ãƒ™ãƒ«ä»˜ã‘ï¼ˆå­˜åœ¨ã—ãªã‘ã‚Œã°é»™ã£ã¦ã‚¹ã‚­ãƒƒãƒ—ï¼‰
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pr.data.number,
                labels: ['catalog','manus']
              });
            } catch (e) {}
