name: Manus merge (all countries â†’ root catalogs via PR)

on:
  push:
    paths:
      - 'data/manus/**/*.json'
      - 'data/manus/*.json'
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      # 1) manus é…ä¸‹ã® JSON ã‚’åˆ—æŒ™ã—ã¦ outputs ã«ï¼ˆãƒãƒ«ãƒãƒ©ã‚¤ãƒ³å®‰å…¨ç‰ˆï¼‰
      - name: List files to pass into Python
        id: list_files
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t FILES < <(find data/manus -type f -name '*.json' | sort)
          echo "Found ${#FILES[@]} files:"
          printf '  - %s\n' "${FILES[@]}"
          {
            echo 'files<<EOF'
            printf '%s\n' "${FILES[@]}"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      # 2) Python ã§å›½åˆ¥ã«ãƒãƒ¼ã‚¸ã—ã€root ã® catalog_<cc>.json ã‚’å†ç”Ÿæˆ
      - name: Build merged catalogs (root/catalog_<cc>.json)
        id: build
        env:
          MANUS_FILE_LIST: ${{ steps.list_files.outputs.files }}
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, os, re
          from collections import defaultdict
          from pathlib import Path

          # â”€â”€ å—ã‘å–ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ï¼ˆæ”¹è¡ŒåŒºåˆ‡ã‚Šï¼‰
          flist = (os.getenv('MANUS_FILE_LIST') or '').splitlines()
          files = [Path(p) for p in flist if p.strip()]
          if not files:
            # å¤‰æ›´ãªã—ã‚’ outputs ã«æ›¸ãå‡ºã™ï¼ˆãƒãƒ«ãƒãƒ©ã‚¤ãƒ³å®‰å…¨ç‰ˆï¼‰
            with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as g:
              g.write('changed<<EOF\nEOF\n')
            raise SystemExit(0)

          RE_CC = re.compile(r'(?:^|/)manus_([a-z]{2})_\d{8}\.json$', re.I)

          def as_list(v):
            if v is None: return []
            return v if isinstance(v, list) else [v]

          def dedup(seq):
            out, seen = [], set()
            for x in seq:
              if x not in seen:
                seen.add(x)
                out.append(x)
            return out

          def load_json(p: Path):
            with p.open('r', encoding='utf-8') as f:
              return json.load(f)

          def dump_json(p: Path, data):
            tmp = p.with_suffix(p.suffix + '.tmp')
            with tmp.open('w', encoding='utf-8') as f:
              json.dump(data, f, ensure_ascii=False, indent=2)
              f.write('\n')
            tmp.replace(p)

          # å›½ã‚³ãƒ¼ãƒ‰ã”ã¨ã«é›†ç´„
          by_cc = defaultdict(list)
          for p in files:
            s = str(p).replace('\\','/')
            m = RE_CC.search(s)
            if m:
              cc = m.group(1).lower()
            else:
              parts = Path(s).parts
              if 'manus' in parts:
                i = parts.index('manus')
                cc = parts[i+1].lower() if i+1 < len(parts) and len(parts[i+1]) == 2 else None
              else:
                cc = None
            if not cc:
              continue

            try:
              raw = load_json(p)
              items = None
              if isinstance(raw, dict):
                for k in ('apps','items','data','list','entries'):
                  if k in raw:
                    items = raw[k]
                    break
                if items is None:
                  items = [raw]
              else:
                items = raw

              if not isinstance(items, list):
                items = [items]

              normed = []
              for it in items:
                if not isinstance(it, dict): continue
                it = it.copy()
                it['id'] = (str(it.get('id') or it.get('name') or '').strip() or None)
                it['name'] = (str(it.get('name') or it.get('id') or '').strip() or '')
                it['symbol'] = it.get('symbol') or 'app.fill'
                it['schemes'] = [s.strip() for s in as_list(it.get('schemes')) if isinstance(s, str) and s.strip()]
                it['universalLinks'] = [u.strip() for u in as_list(it.get('universalLinks')) if isinstance(u, str) and u.strip()]
                it['webHosts'] = [h.strip() for h in as_list(it.get('webHosts')) if isinstance(h, str) and h.strip()]
                it['aliases'] = [a.strip() for a in as_list(it.get('aliases')) if isinstance(a, str) and a.strip()]
                it['categories'] = [c.strip() for c in as_list(it.get('categories')) if isinstance(c, str) and c.strip()]
                if not it['id']:
                  continue

                # source ã®ä»˜ä¸/çµ±åˆï¼ˆmanus ã®ç”±æ¥ã‚’è¨˜éŒ²ï¼‰
                src = it.get('source') or {}
                if not isinstance(src, dict): src = {}
                src['country'] = src.get('country') or cc.upper()
                via = as_list(src.get('via'))
                via.append('manus')
                src['via'] = dedup([v for v in via if v])
                it['source'] = src

                # é…åˆ— dedup
                for k in ('schemes','universalLinks','webHosts','aliases','categories'):
                  it[k] = dedup(it[k])

                normed.append(it)

              if normed:
                by_cc[cc].extend(normed)
            except Exception as e:
              print(f"[warn] skip {p}: {e}")

          changed = []

          for cc, items in by_cc.items():
            out = Path(f"catalog_{cc}.json")
            existing = []
            if out.exists():
              try:
                existing = load_json(out)
                if not isinstance(existing, list): existing = []
              except Exception:
                existing = []

            # id ã§ãƒãƒ¼ã‚¸
            by_id = { (x.get('id')): x for x in existing if isinstance(x, dict) and x.get('id') }
            for it in items:
              _id = it['id']
              if _id in by_id:
                cur = dict(by_id[_id])
                # å˜ä¸€å€¤ã¯æ–°ã—ã„å€¤ã‚’å„ªå…ˆ
                for k in ('name','symbol'):
                  if it.get(k): cur[k] = it[k]
                # é…åˆ—ã¯ãƒ¦ãƒ‹ã‚ªãƒ³
                for k in ('schemes','universalLinks','webHosts','aliases','categories'):
                  cur[k] = sorted(set(as_list(cur.get(k)) + as_list(it.get(k))))
                # source ã¯ via ã‚’ãƒ¦ãƒ‹ã‚ªãƒ³ã€country ã¯æ—¢å­˜/æ–°è¦ã®ã©ã¡ã‚‰ã‹å„ªå…ˆï¼ˆæ–°è¦å„ªå…ˆï¼‰
                cur_src = cur.get('source') or {}
                it_src  = it.get('source') or {}
                cur['source'] = {
                  'country': it_src.get('country') or cur_src.get('country'),
                  'via': sorted(set(as_list(cur_src.get('via')) + as_list(it_src.get('via'))))
                }
                by_id[_id] = cur
              else:
                by_id[_id] = it

            merged = sorted(by_id.values(), key=lambda x: x.get('id',''))
            dump_json(out, merged)
            changed.append(cc)

          # å¤‰æ›´ã•ã‚ŒãŸå›½ã‚³ãƒ¼ãƒ‰ã‚’ outputs ã«ï¼ˆãƒãƒ«ãƒãƒ©ã‚¤ãƒ³ï¼‰
          with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as g:
            g.write('changed<<EOF\n')
            for cc in changed:
              g.write(cc + '\n')
            g.write('EOF\n')
          PY

      # 3) å¤‰æ›´ãŒã‚ã‚Œã°ãƒ–ãƒ©ãƒ³ãƒåˆ‡ã£ã¦ã‚³ãƒŸãƒƒãƒˆ
      - name: Commit changes on branch
        id: commit
        if: steps.build.outputs.changed != ''
        shell: bash
        run: |
          set -euo pipefail
          TS="$(date +'%Y%m%d-%H%M%S')"
          BR="chore/manus/${TS}"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BR"
          git add catalog_*.json
          # å¤‰æ›´ãŒç„¡ã‘ã‚Œã°ã“ã“ã§çµ‚äº†
          if git diff --cached --quiet; then
            echo "branch=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          git commit -m "chore(manus): merge drops into catalogs (${TS})"
          git push -u origin "$BR"
          echo "branch=$BR" >> "$GITHUB_OUTPUT"

      # 4) è‡ªå‹•ã§ PR ã‚’ä½œæˆï¼ˆãƒ©ãƒ™ãƒ«ä»˜ä¸ã€Squash æ¨å¥¨ã‚³ãƒ¡ãƒ³ãƒˆï¼‰
      - name: Open PR (label:manus,catalog;comment:squash)
        if: steps.commit.outputs.branch != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const branch = `${{ steps.commit.outputs.branch }}`;
            const owner  = context.repo.owner;
            const repo   = context.repo.repo;

            const title = `chore(manus): merge drops into catalogs (${new Date().toISOString().slice(0,10)})`;
            const body  = [
              'Manus ã®å‡ºåŠ›ã‚’å„å›½ã‚«ã‚¿ãƒ­ã‚°ã¸è‡ªå‹•ãƒãƒ¼ã‚¸ã—ã¾ã—ãŸã€‚',
              '',
              'â€” ç½®ãå ´: `data/manus/**/manus_<cc>_YYYYMMDD.json`ï¼ˆãƒ•ãƒ©ãƒƒãƒˆ/ãƒã‚¹ãƒˆã©ã¡ã‚‰ã§ã‚‚å¯ï¼‰',
              'â€” æ—¢å­˜é …ç›®ã¯ãƒ¦ãƒ‹ã‚ªãƒ³ã§å®‰å…¨ã«çµ±åˆï¼ˆé…åˆ—ã¯å’Œé›†åˆã€source.via ã« `manus` è¿½åŠ ï¼‰',
              '',
              'ğŸŸ¢ **ãƒãƒ¼ã‚¸æ–¹æ³•ã¯ã€ŒSquash and mergeã€æ¨å¥¨**ï¼ˆå±¥æ­´ã‚’æ—¥ä»˜ã‚³ãƒŸãƒƒãƒˆã§ç°¡æ½”ã«ç¶­æŒï¼‰'
            ].join('\n');

            const pr = await github.rest.pulls.create({
              owner, repo,
              title, body,
              head: branch,
              base: 'main'
            });

            try {
              await github.rest.issues.addLabels({
                owner, repo,
                issue_number: pr.data.number,
                labels: ['catalog','manus']
              });
            } catch (e) {}
